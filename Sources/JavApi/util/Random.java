/*
 * SPDX-FileCopyrightText: 2023, 2024 - Sebastian Ritter <bastie@users.noreply.github.com>
 * SPDX-License-Identifier: ASL2
 */

extension java.util {
  
  
  /**
   * This class provides methods that generates pseudo-random numbers of different
   * types, such as {@code int}, {@code long}, {@code double}, and {@code float}.
   *
   * @see Properties
   * @see PropertyResourceBundle
   */
  open class Random : Hashable {
    public static func == (lhs: java.util.Random, rhs: java.util.Random) -> Bool {
      return lhs.seed == rhs.seed
    }
    
    
    private static let multiplier : Int64 = Int64 (0x5deece66d);
    
    /**
     * The boolean value indicating if the second Gaussian number is available.
     *
     * @serial
     */
    private var haveNextNextGaussian : Bool;
    
    /**
     * @serial It is associated with the internal state of this generator.
     */
    private var seed : Int64;
    
    /**
     * The second Gaussian generated number.
     *
     * @serial
     */
    private var nextNextGaussian : Double;
    
    /**
     * Construct a random generator with the current time of day in milliseconds
     * as the initial state.
     *
     * @see #setSeed
     */
    public init() {
      setSeed(System.currentTimeMillis() + hash())// hashCode());
    }
    
    /**
     * Construct a random generator with the given {@code seed} as the
     * initial state.
     *
     * @param seed
     *            the seed that will determine the initial state of this random
     *            number generator.
     * @see #setSeed
     */
    public init (_ seed : Int64) {
      setSeed(seed);
    }
    
    /**
     * Returns a pseudo-random uniformly distributed {@code int} value of
     * the number of bits specified by the argument {@code bits} as
     * described by Donald E. Knuth in <i>The Art of Computer Programming,
     * Volume 2: Seminumerical Algorithms</i>, section 3.2.1.
     *
     * @param bits
     *            number of bits of the returned value.
     * @return a pseudo-random generated int number.
     * @see #nextBytes
     * @see #nextDouble
     * @see #nextFloat
     * @see #nextInt()
     * @see #nextInt(int)
     * @see #nextGaussian
     * @see #nextLong
     */
    public func next(_ bits : Int) -> Int {
      seed = (seed * java.util.Random.multiplier + Int64(0xb)) & ((Int64(1) << 48) - 1);
      return Int (seed >>> (48 - bits));
    }
    
    /**
     * Returns the next pseudo-random, uniformly distributed {@code boolean} value
     * generated by this generator.
     *
     * @return a pseudo-random, uniformly distributed boolean value.
     */
    public func nextBoolean() -> Bool {
      return next(1) != 0;
    }
    
    /**
     * Modifies the {@code byte} array by a random sequence of {@code byte}s generated by this
     * random number generator.
     *
     * @param buf
     *            non-null array to contain the new random {@code byte}s.
     * @see #next
     */
    public func nextBytes(_ _buf : [byte]) {
      var buf = _buf
      var rand = 0
      var count = 0
      var loop = 0
      while (count < buf.length) {
        if (loop == 0) {
          rand = nextInt();
          loop = 3;
        } else {
          loop -= 1;
        }
        count += 1
        buf[count] = (byte) rand;
        rand >>= 8;
      }
    }
    
    /**
     * Generates a normally distributed random {@code double} number between 0.0
     * inclusively and 1.0 exclusively.
     *
     * @return a random {@code double} in the range [0.0 - 1.0)
     * @see #nextFloat
     */
    public func nextDouble() -> Double {
      return ((((Int64) (next(26) << 27)) + next(27)) / Double(Int64(1) << 53))
    }
    
    /**
     * Generates a normally distributed random {@code float} number between 0.0
     * inclusively and 1.0 exclusively.
     *
     * @return float a random {@code float} number between [0.0 and 1.0)
     * @see #nextDouble
     */
    public func nextFloat() -> Float{
      return Float(next(24)) / Float(16777216)
    }
    
    /**
     * Pseudo-randomly generates (approximately) a normally distributed
     * {@code double} value with mean 0.0 and a standard deviation value
     * of {@code 1.0} using the <i>polar method<i> of G. E. P. Box, M.
     * E. Muller, and G. Marsaglia, as described by Donald E. Knuth in <i>The
     * Art of Computer Programming, Volume 2: Seminumerical Algorithms</i>,
     * section 3.4.1, subsection C, algorithm P.
     *
     * @return a random {@code double}
     * @see #nextDouble
     */
    public func nextGaussian() -> Double{
      if (haveNextNextGaussian) { // if X1 has been returned, return the
                                  // second Gaussian
        haveNextNextGaussian = false;
        return nextNextGaussian;
      }
      
      var v1 : Double
      var v2 : Double
      var s : Double
      repeat {
        v1 = 2 * nextDouble() - 1; // Generates two independent random
                                   // variables U1, U2
        v2 = 2 * nextDouble() - 1;
        s = v1 * v1 + v2 * v2;
      } while (s >= 1);
      var norm : Double = Math.sqrt(-2 * Math.log(s) / s);
      nextNextGaussian = v2 * norm; // should that not be norm instead
                                    // of multiplier ?
      haveNextNextGaussian = true;
      return v1 * norm; // should that not be norm instead of multiplier
                        // ?
    }
    
    /**
     * Generates a uniformly distributed 32-bit {@code int} value from
     * the random number sequence.
     *
     * @return a uniformly distributed {@code int} value.
     * @see java.lang.Integer#MAX_VALUE
     * @see java.lang.Integer#MIN_VALUE
     * @see #next
     * @see #nextLong
     */
    public func nextInt() -> Int {
      return next(32);
    }
    
    /**
     * Returns a new pseudo-random {@code int} value which is uniformly distributed
     * between 0 (inclusively) and the value of {@code n} (exclusively).
     *
     * @param n
     *            the exclusive upper border of the range [0 - n).
     * @return a random {@code int}.
     */
    public func nextInt(_ n : Int) throws -> Int {
      if (n > 0) {
        if ((n & -n) == n) {
          return Int ((Int64(n) * Int64(next(31))) >> 31);
        }
        var bits : Int
        var val : Int;
        repeat {
          bits = next(31);
          val = bits % n;
        } while (bits - val + (n - 1) < 0);
        return val;
      }
      throw Throwable.IllegalArgumentException
    }
    
    /**
     * Generates a uniformly distributed 64-bit integer value from
     * the random number sequence.
     *
     * @return 64-bit random integer.
     * @see java.lang.Integer#MAX_VALUE
     * @see java.lang.Integer#MIN_VALUE
     * @see #next
     * @see #nextInt()
     * @see #nextInt(int)
     */
    public func nextLong() -> Int64 {
      return Int64 (next(32) << 32) + Int64(next(32))
    }
    
    /**
     * Modifies the seed a using linear congruential formula presented in <i>The
     * Art of Computer Programming, Volume 2</i>, Section 3.2.1.
     *
     * @param seed
     *            the seed that alters the state of the random number generator.
     * @see #next
     * @see #Random()
     * @see #Random(long)
     */
    public func setSeed(_ seed : Int64 ) {
      self.seed = (seed ^ java.util.Random.multiplier) & ((Int64(1) << 48) - 1);
      haveNextNextGaussian = false;
    }
  }
}
